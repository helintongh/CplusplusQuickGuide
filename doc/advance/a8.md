## 指针详解

### 什么是指针

指针是一个变量,它用来存放其他变量的地址。

为了解释更清楚,看一段代码:

```c++
int a;
int *p;
p = &a;
a = 5;
// print为伪代码
print p; // 1; 打印204
print &a; // 2; 打印204
print &p; // 3; 64 
print *p; // 4; 5
*p = 8; // 5; a变为8
```

**p是地址,`*p`是该地址存储的值.**

p和a的关系如下图所示.

![](./resource/pointer/p1.png)

解释一下上述代码。语句1;会输出204而`&a`意味取a的地址,所以语句2;也输出204。

可知,**指针变量p其实存储的是绑定变量a的地址。**而语句3;打印64代表指针变量p也有其本身的地址。(同样可以用另一个指针指向地址64指向p)

执行语句5后再打印a的值会发现a变为了5。**当指针p指向a后,改变`*p`将a存储的值。**



### 指针的类型和运算

指针可以为所有变量的类型,也可以为**void**万能类型.

不同类型的指针声明如下

```c++
char *p;
int *p;
double *p;
...
```

下面看一段实际的指针使用场景.

```c++
#include <stdio.h>
int main()
{
  /*
  int a;
  int *p; 
  a = 10;
  p = &a;
  */
  int a = 10;
  int *p = &a; // 1;
  printf("a = %d\n", a);
  printf("%d\n", p);
  printf("%d\n", *p);
  *p = 12;
  printf("a = %d\n", a);
  int b =20;
  *p = b; // 2;
  printf("a = %d\n", a); // 3;
  p = &b; // 4;
  // 指针运算
  printf("%d\n", p); // 假设p为2002
  printf("size of integer is %d bytes\n", sizeof(int));
  printf("%d\n", p+1); // 若p为2002,p+1为2006
}
```

上述代码在DEV-C++5.11中打印为:

```
a = 10
6487572
10
a = 12
a = 20
6487568
size of integer is 4 bytes
6487572
```

`&a`为变量a的地址,语句1;把变量a的地址赋给了指针变量p,此时输出a,p,`*p`分别得到变量a的值,a的地址(p存放的),a的值(p指向的地址的值)。

需要说明语句2;此时p仍然指向a,语句2;是指修改p所指向的地址所存储的值。在后续的语句3;打印变量a的值可以看到a值为20.

而语句4;才是让指针p指向变量b.

上述代码还涉及到了指针的运算:

下面的代码是输出指针p存放的值,即指向变量的地址。假定p指向的变量地址为2002,那么p+1的地址为2006.因为p是int型指针,一个int型变量占4字节大小,p+1即是指向下一个int的位置。

```c++
// 指针运算
printf("%d\n", p); // 假设p为2002
printf("size of integer is %d bytes\n", sizeof(int));
printf("%d\n", p+1); // 若p为2002,p+1为2006
```

下面再来看一段代码

```c
#include <stdio.h>
int main()
{
  int a = 1025;
  int *p;
  p = &a;
  printf("size of integer is %d bytes\n", sizeof(int));
  printf("Address = %d, value = %d\n",p, *p);
  char *p0;
  p0 = (char*)p;
  printf("size of char is %d bytes\n", sizeof(char));
  printf("Address = %d, value = %d\n", p0, *p0);
  
}
```

上述代码输出:

```c
size of integer is 4 bytes
Address = 6487564, value = 1025
size of char is 1 bytes
Address = 6487564, value = 1
  
```

为什么p0的值是1呢？看下图int型变量是4字节` int a = 1025;`语句执行后a实际上的内存位置如下(一般来说内存是从低地址到高地址存储)。而语句`p0 = (char*)p;`实际上是取得200位置的内存也就是byte3即为1。

![](./resource/pointer/p2.png)



由此可知,各种类型之间没有本质区别，只是解释内存中的数据方式不同。例如，对于int型指针p，解引用时，会解析4字节，算术运算时，也是以该类型占用空间大小为单位，所以p+1，移动4字节，解引用，处理4字节内容，得到1025。对于char型指针p0，解引用时，会解析1个字节，算术运算时，也是以sizeof(char)为单位，所以p0+1，移动一字节，解引用，处理1字节，得到`00000100`为4。

#### void指针用处

上述代码会遇到一个编译器告警,此时就需要void型指针了上述代码改为

```c
#include <stdio.h>
int main()
{
  int a = 1025;
  int *p;
  p = &a;
  printf("size of integer is %d bytes\n", sizeof(int));
  printf("Address = %d, value = %d\n",p, *p);
  void *p0;
  p0 = p;
  printf("Address = %d\n", p0);
}
```

此时编译器不会告警,void型指针相当于一个泛型指针可以转化为任意类型的指针。

换言之,任何类型指针都可以转为`void*`，它无条件接受各种类型。

### 指向指针的指针

![](./resource/pointer/p3.png)

上图左边是伪代码右边是内存位置。

加入有一个变量x值为5它在内存中地址是225。此时`int *p`指向它,p存储的是x的地址所以p的值为225。然后我们通过`*p`赋值修改了x的值为6。此时声明一个`int **`型变量q(指向指针的指针)它指向p.

此时q的值为p的地址225。举一反三,声明一个`int ***`型变量r,r指向q。那么r的值一定为205(q的地址)。

有了图看如下代码:

```c
#include <stdio.h>

int main()
{
  int x = 5;
  int* p = &x;
  *p = 6;
  int** q = &p;
  int*** r = &q;
  printf("%d\n", *p);
  printf("%d\n", *q);
  printf("%d\n", **q);
  printf("%d\n", **r);
  printf("%d\n", ***r);
  ***r = 10; // 等价于**q = 10;
  printf("x = %d\n", x);
}
```

上述代码打印

```
6
6487572
6
6487572
6
x = 10
```

其中`***r = 10;` 和`**q = 10;`是等价的，可以自行尝试。上面的代码就验证了上述的图片。

### 函数传值 vs 传引用

```c
#include <stdio.h>
void Increment(int a)
{
  a = a + 1;
}

void IncrementP(int *a)
{
  *a = (*a) + 1;
}
int main()
{
  int a;
  a = 10;
  Increment(a);
  printf("a = %d\n", a);
  IncrementP(&a);
  printf("a = %d\n", a);
}
```
上述代码输出:

```
a = 10
a = 11
```

Increment函数没有修改main的局部变量a,而IncrementP函数成功将变量a加1。

下图左边是Increment函数,右边是IncrementP

![](./resource/pointer/p4.png)

由函数调用栈可知,Increment函数中的a其实是局部变量a和main函数中的局部变量a有不同的内存。修改函数中的局部变量不会对main中的产生影响

而IncrementP函数中的局部变量*a获取到了main函数局部变量a的地址然后改变了其对应的值。

结论:使用指针作为函数参数时就是在传引用,传引用可以节省内存并且修改指向内容的值。



### 指针和数组

#### 指针和一位数组

```c
#include <stdio.h>
int main()
{
  int a[] = {2, 4, 5, 8 ,1};
  printf("%d\n", a);
  printf("%d\n", &a[0]);
  printf("%d\n", a[0]);
  printf("%d\n", *a);
  printf("%d\n", a+2);
  printf("%d\n", *(a+2));
}
```



#### 数组作为函数参数

#### 指针和字符数组



#### 指针和二维数组

